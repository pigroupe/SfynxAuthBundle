<?php
namespace Sfynx\AuthBundle\Infrastructure\Persistence\Adapter\Query\Orm;

use Doctrine\ORM\EntityRepository;
use Sfynx\AuthBundle\Layers\Domain\Repository\Query\UserQueryRepositoryInterface;
use Sfynx\CoreBundle\Layers\Infrastructure\Persistence\Adapter\Generalisation\Orm\Traits\TraitTranslation;
use Sfynx\CoreBundle\Layers\Infrastructure\Persistence\Adapter\Generalisation\Orm\AbstractQueryRepository;

/**
 * User Repository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 *
 * @category   Sfynx\AuthBundle
 * @package    Infrastructure
 * @subpackage Persistence\Repository\Query\Orm
 * @author     Etienne de Longeaux <etienne.delongeaux@gmail.com>
 * @since      2012-01-06
 */
class UserRepository extends AbstractQueryRepository implements UserQueryRepositoryInterface
{
    /**
     * Gets all entities by one category.
     *
     * @param string  $category
     * @param integer $MaxResults
     * @param string  $ORDER_PublishDate ['ASC', 'DESC']
     * @param string  $ORDER_Position    ['ASC', 'DESC']
     * @param boolean $enabled
     *
     * @return \Doctrine\ORM\QueryBuilder
     * @access public
     * @author Etienne de Longeaux <etienne.delongeaux@gmail.com>
     * @since  2012-03-15
     */
    public function getAllByParams($category = '', $MaxResults = null, $ORDER_PublishDate = '', $ORDER_Position = '', $enabled = true)
    {
        $query = $this->createQueryBuilder('a')->select('a');
        if ($enabled) {
            $query->andWhere('a.enabled = 1');
        }
        if (!empty($ORDER_PublishDate) && !empty($ORDER_Position)){
            $query
            ->orderBy('a.created_at', $ORDER_PublishDate)
            ->addOrderBy('a.position', $ORDER_Position);
        } elseif (!empty($ORDER_PublishDate) && empty($ORDER_Position)) {
            $query
            ->orderBy('a.created_at', $ORDER_PublishDate);
        } elseif (empty($ORDER_PublishDate) && !empty($ORDER_Position)) {
            $query
            ->orderBy('a.position', $ORDER_Position);
        }
        if (!(null === $MaxResults)) {
            $query->setMaxResults($MaxResults);
        }

        return $query;
    }

    /**
     * Gets all editor users with a minimum data
     *
     * @return \Doctrine\ORM\QueryBuilder
     * @access public
     * @author Etienne de Longeaux <etienne.delongeaux@gmail.com>
     * @since  2012-03-15
     */
    public function getAllEditorUsers()
    {
        return $this
            ->createQueryBuilder('a')
            ->select('a.id, a.name, a.roles')
            ->where("a.roles NOT LIKE '%ROLE_SUBSCRIBER%'")
            ->andWhere("a.roles NOT LIKE '%ROLE_MEMBER%'")
            ->andWhere("a.roles NOT LIKE '%ROLE_PROVIDER%'")
            ->andWhere("a.roles NOT LIKE '%ROLE_CUSTOMER%'")
            ->orderBy('a.name', 'ASC');
    }

    /**
     * Gets all editor users with all data
     *
     * @return \Doctrine\ORM\QueryBuilder
     * @access public
     * @author Etienne de Longeaux <etienne.delongeaux@gmail.com>
     * @since  2012-03-15
     */
    public function getAllEditorUsersWithLazy()
    {
        return $this
            ->createQueryBuilder('a')
            ->leftJoin('a.groups', 'gps')
            ->andWhere("a.roles NOT LIKE '%ROLE_SUBSCRIBER%'")
            ->andWhere("a.roles NOT LIKE '%ROLE_MEMBER%'")
            ->andWhere("a.roles NOT LIKE '%ROLE_PROVIDER%'")
            ->andWhere("a.roles NOT LIKE '%ROLE_CUSTOMER%'");
    }

    /**
     * we return the user enity associated to the user token and the application.
     *
     * @param string $token
     * @param string $application
     *
     * @return mixed
     * @access public
     * @author Etienne de Longeaux <etienne.delongeaux@gmail.com>
     */
    public function getUserByTokenAndApplication($token, $application)
    {
        $like_app = array(strtoupper($application.'::'.$token));
        $like = serialize($like_app);
        $query = $this
            ->createQueryBuilder('a')
            ->select('a')
            ->andWhere("a.applicationTokens = '{$like}'")
            ->getQuery();
        $query = $this->cacheQuery($query, 84600);
        return $query->getOneOrNullResult();
    }

    /**
     * we return the user enity associated to the user token and the application.
     *
     * @param string $token
     * @param string $application
     *
     * @return mixed
     * @access public
     * @author Etienne de Longeaux <etienne.delongeaux@gmail.com>
     */
    public function getUserByTokenAndApplicationMultiple($token, $application)
    {
        $like  = strtoupper($application.'::'.$token);
        $query = $this
            ->createQueryBuilder('a')
            ->select('a')
            ->andWhere("a.applicationTokens LIKE '%{$like}%'")
            ->getQuery();
        // ATTENTION avec a.applicationTokens LIKE "%..%" empeche l'utilisation de 'index sur la recherceh par la valeur de application_token
        // Avec un site à très fort traffic, cela explose alors la bdd si pas d'index sur application token.
        // create cache tag of the query
        $query = $this->cacheQuery($query, 84600);
        return $query->getOneOrNullResult();
    }
}
